"""
@PURPOSE: Temuå‘å¸ƒæ§åˆ¶å™¨ï¼Œä¸²è”é€‰æ‹©åº—é“ºã€è®¾ç½®ä¾›è´§ä»·ã€æ‰¹é‡å‘å¸ƒç­‰æ­¥éª¤å¹¶ä¿è¯æµç¨‹ç¨³å®šã€?
@OUTLINE:
  - class PublishController: è´Ÿè´£å‘å¸ƒå·¥ä½œæµã€é€‰æ‹©å™¨åŠ è½½ä¸ä¸Šä¸‹æ–‡å¤ä½?
  - def select_all_20_products(): å…¨é€‰å½“å‰é¡µ 20 æ¡å•†å“ï¼Œå‡†å¤‡å‘å¸ƒä¸Šä¸‹æ–?
  - def select_shop(): é€‰æ‹©ç›®æ ‡åº—é“ºæˆ–å…¨é€‰åº—é“ºå¹¶ç¡®è®¤
  - def set_supply_price(): æ‰“å¼€ä¾›è´§ä»·å¼¹çª—å¹¶æŒ?SOP é…ç½®å…¬å¼
  - def batch_publish(): æ‰¹é‡å‘å¸ƒå¹¶å¤„ç†åŒé‡ç¡®è®¤å¼¹çª?
  - def execute_publish_workflow(): ä¸²è”å®Œæ•´å‘å¸ƒæµç¨‹å¹¶è¿”å›ç»“æ„åŒ–ç»“æœ
@GOTCHAS:
  - é€‰æ‹©å™¨ä¾èµ–é…ç½®æ–‡ä»¶ï¼Œç¼ºå¤±æˆ–å¤±æ•ˆæ—¶ä¼šå¯ç”¨å…œåº•é€‰æ‹©å™¨å¹¶è®°å½•è­¦å‘Š
  - Playwright æ“ä½œéœ€è¦ç­‰å¾…å¯è§ä¸”å¯ç”¨ï¼Œå¿…è¦æ—¶æ»šåŠ¨åˆ°è§†å£å¹¶é‡è¯•
@DEPENDENCIES:
  - å†…éƒ¨: data_processor.price_calculator.PriceCalculator, utils.selector_race.TIMEOUTS
  - å¤–éƒ¨: playwright.async_api, loguru
@RELATED: apps/temu-auto-publish/config/miaoshou_selectors_v2.json
"""

from __future__ import annotations

import asyncio
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Mapping, Sequence

from loguru import logger
from playwright.async_api import Locator, Page, TimeoutError as PlaywrightTimeoutError

from ..data_processor.price_calculator import PriceCalculator
from ..utils.page_load_decorator import wait_dom_loaded
from ..utils.selector_race import TIMEOUTS

SelectorEntries = Sequence[str] | str | None


@dataclass
class PublishWorkflowResult:
    """å‘å¸ƒå·¥ä½œæµçš„ç»“æ„åŒ–ç»“æ?"""

    shop_selected: bool = False
    price_set: bool = False
    published: bool = False

    @property
    def success(self) -> bool:
        """æ•´ä½“æ˜¯å¦æˆåŠŸ."""
        return self.shop_selected and self.price_set and self.published

    def to_dict(self) -> dict[str, Any]:
        """è½¬æ¢ä¸ºè¾“å‡ºå­—å…?"""
        return {
            "success": self.success,
            "shop_selected": self.shop_selected,
            "price_set": self.price_set,
            "published": self.published,
            "publish_result": {
                "success_count": 20 if self.published else 0,
                "fail_count": 0 if self.published else 20,
                "total_count": 20,
            },
        }


class PublishController:
    """Temu å‘å¸ƒæ§åˆ¶å™?

    ä¸²è” SOP æ­¥éª¤ 8-10ï¼ˆé€‰æ‹©åº—é“ºã€è®¾ç½®ä¾›è´§ä»·ã€æ‰¹é‡å‘å¸ƒï¼‰ï¼Œå¹¶åœ¨å¤±è´¥æ—¶æä¾›æ¸…æ™°çš„æ—¥å¿—ä¸å›é€€ã€?

    Attributes:
        selectors: é€‰æ‹©å™¨é…ç½®å­—å…?
        price_calculator: ä»·æ ¼è®¡ç®—å™¨ï¼Œç”¨äºæ—¥å¿—/æ ¡éªŒ.
    Examples:
        >>> controller = PublishController()
        >>> await controller.select_shop(page, "æµ‹è¯•åº—é“º")
        >>> await controller.set_supply_price(page, [{"cost": 10.0}])
        >>> await controller.batch_publish(page)
    """

    def __init__(self, selector_path: str = "config/miaoshou_selectors_v2.json") -> None:
        """åˆå§‹åŒ–å‘å¸ƒæ§åˆ¶å™¨."""
        self.selector_path = self._resolve_selector_path(selector_path)
        self.selectors = self._load_selectors()
        self.price_calculator = PriceCalculator()
        self._publish_context_ready = False
        logger.info("å‘å¸ƒæ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆï¼Œé€‰æ‹©å™¨é…ç½®è·¯å¾? %s", self.selector_path)

    def _resolve_selector_path(self, selector_path: str) -> Path:
        """å°†é€‰æ‹©å™¨é…ç½®è·¯å¾„è½¬æ¢ä¸ºç»å¯¹è·¯å¾„."""
        selector_file = Path(selector_path)
        if selector_file.is_absolute():
            return selector_file

        current_file = Path(__file__)
        project_root = current_file.parent.parent.parent
        return project_root / selector_file

    def _load_selectors(self) -> dict[str, Any]:
        """åŠ è½½é€‰æ‹©å™¨é…ç½®å¹¶åšåŸºæœ¬æ ¡éª?"""
        if not self.selector_path.exists():
            logger.warning(
                "é€‰æ‹©å™¨é…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°†ä½¿ç”¨å…œåº•é€‰æ‹©å™? %s", self.selector_path
            )
            return {}

        try:
            with self.selector_path.open("r", encoding="utf-8") as f:
                data = json.load(f)
            if not isinstance(data, dict):
                raise ValueError("é€‰æ‹©å™¨é…ç½®ä¸æ˜¯å­—å…?)
            logger.debug(
                "é€‰æ‹©å™¨é…ç½®å·²åŠ è½½ version=%s, last_updated=%s",
                data.get("version"),
                data.get("last_updated"),
            )
            return data
        except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
            logger.error("åŠ è½½é€‰æ‹©å™¨é…ç½®å¤±è´¥ï¼Œå°†ä½¿ç”¨å…œåº•é€‰æ‹©å™? %s", exc)
            return {}

    def _invalidate_publish_context(self) -> None:
        """æ ‡è®°å½“å‰é€‰ä¸­ä¸Šä¸‹æ–‡å¤±æ•?"""
        self._publish_context_ready = False

    @staticmethod
    def _dedup_selectors(candidates: list[str]) -> list[str]:
        """æŒ‰é¡ºåºå»é‡é€‰æ‹©å™¨åˆ—è¡?"""
        seen: set[str] = set()
        deduped: list[str] = []
        for selector in candidates:
            if selector not in seen:
                deduped.append(selector)
                seen.add(selector)
        return deduped

    def _get_selector_candidates(self, *entries: SelectorEntries) -> list[str]:
        """å±•å¼€é…ç½®ä¸å…œåº•é€‰æ‹©å™¨ï¼Œè‡ªåŠ¨å»é‡."""
        candidates: list[str] = []
        for entry in entries:
            if entry is None:
                continue
            if isinstance(entry, str):
                parts = [part.strip() for part in entry.split(",") if part.strip()]
                candidates.extend(parts)
            else:
                for item in entry:
                    if isinstance(item, str) and item.strip():
                        candidates.append(item.strip())
        return self._dedup_selectors(candidates)

    async def _click_first_available(
        self,
        page: Page,
        selectors: Sequence[str],
        *,
        visible_timeout_ms: int = 4_000,
        click_timeout_ms: int = 3_000,
        attempts: int = 3,
        context: str = "",
    ) -> str | None:
        """å°è¯•ä¾æ¬¡ç‚¹å‡»ç¬¬ä¸€ä¸ªå¯è§ä¸”å¯ç”¨çš„é€‰æ‹©å™?"""
        last_error: Exception | None = None
        #ç­‰å¾…é¡µé¢åŠ è½½å®Œæ¯•
        await page.wait_for_load_state("domcontentloaded")


        for attempt in range(attempts):
            for selector in selectors:
                locator = page.locator(selector).first
                try:
                    await locator.wait_for(state="visible", timeout=visible_timeout_ms)
                    if not await locator.is_enabled():
                        last_error = RuntimeError("å…ƒç´ æœªå¯ç”?)
                        logger.debug(
                            "å…ƒç´ ç¦ç”¨ selector=%s ctx=%s", selector, context
                        )
                        continue
                    await locator.scroll_into_view_if_needed(timeout=1_000)
                    await locator.click(timeout=click_timeout_ms)
                    logger.debug(
                        "ç‚¹å‡»æˆåŠŸ selector=%s ctx=%s attempt=%s/%s",
                        selector,
                        context,
                        attempt + 1,
                        attempts,
                    )
                    return selector
                except PlaywrightTimeoutError as exc:
                    last_error = exc
                    logger.debug(
                        "ç­‰å¾…å¯è§è¶…æ—¶ selector=%s ctx=%s err=%s",
                        selector,
                        context,
                        exc,
                    )
                except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
                    last_error = exc
                    logger.debug(
                        "ç‚¹å‡»å¤±è´¥ selector=%s ctx=%s err=%s", selector, context, exc
                    )
            if attempt < attempts - 1:
                await asyncio.sleep(0.3 + 0.2 * attempt)
        if last_error:
            logger.debug("æ‰€æœ‰é€‰æ‹©å™¨å‡ä¸å¯ç”?ctx=%s err=%s", context, last_error)
        return None

    async def _first_visible_locator(
        self,
        page: Page,
        selectors: Sequence[str],
        *,
        timeout_ms: int,
        context: str,
    ) -> Locator | None:
        """æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯è§çš„ Locator."""
        for selector in selectors:
            locator = page.locator(selector).first
            try:
                await locator.wait_for(state="visible", timeout=timeout_ms)
                return locator
            except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
                logger.debug(
                    "ç­‰å¾…å¯è§å¤±è´¥ selector=%s ctx=%s err=%s",
                    selector,
                    context,
                    exc,
                )
        return None

    async def _ensure_publish_context(
        self,
        page: Page,
        *,
        force: bool = False,
    ) -> None:
        """ç¡®ä¿å½“å‰åœ¨å‘å¸ƒé¡µä¸”å·²å…¨é€?20 æ¡å•†å“?"""
        await page.wait_for_load_state("domcontentloaded")

        if self._publish_context_ready and not force:
            return

        await self._reset_to_all_tab(page)
        selected = await self.select_all_20_products(
            page,
            require_load_state=force or not self._publish_context_ready,
        )
        if not selected:
            raise RuntimeError("å…¨é€‰å•†å“å¤±è´¥ï¼Œæ— æ³•ç»§ç»­å‘å¸ƒæµç¨‹")
        self._publish_context_ready = True

    async def select_all_20_products(
        self,
        page: Page,
        *,
        require_load_state: bool = True,
    ) -> bool:
        """å…¨é€‰å½“å‰é¡µ 20 æ¡äº§å“?"""
        await page.wait_for_load_state("domcontentloaded")

        logger.info("å…¨é€‰å½“å‰é¡µäº§å“ï¼ˆç›®æ ?20 æ¡ï¼‰...")
        if require_load_state:
            await wait_dom_loaded(page, context="[select all 20]")

        collection_box_config = self.selectors.get("collection_box", {})
        pagination_config = collection_box_config.get("pagination", {})
        configured_select_all = pagination_config.get("select_all")
        select_all_candidates = self._get_selector_candidates(
            configured_select_all,
            "button:has-text('å…¨é€?)",
            "text='å…¨é€?",
            "label:has-text('å…¨é€?)",
        )

        try:
            clicked_selector = await self._click_first_available(
                page,
                select_all_candidates,
                visible_timeout_ms=TIMEOUTS.SLOW,
                context="select_all",
            )
            if not clicked_selector:
                raise RuntimeError("æœªå‘½ä¸­ã€å…¨é€‰ã€æŒ‰é’?)

            logger.success("å·²å…¨é€‰å½“å‰é¡µäº§å“ selector=%s", clicked_selector)
            self._publish_context_ready = True
            return True
        except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
            logger.error("å…¨é€‰äº§å“å¤±è´? %s", exc)
            self._invalidate_publish_context()
            return False

    async def _reset_to_all_tab(self, page: Page) -> None:
        """å¤ä½åˆ°ã€Œå…¨éƒ¨ã€TABï¼Œç¡®ä¿åç»­æ“ä½œåœ¨æ­£ç¡®çš„åˆ—è¡?"""
        await page.wait_for_load_state("domcontentloaded")

        temu_tabs = (
            self.selectors.get("temu_collect_box", {})
            .get("tabs", {})
            .get("all", [])
        )
        collection_tabs = (
            self.selectors.get("collection_box", {})
            .get("tabs", {})
            .get("all", [])
        )

        configured_selectors = self._get_selector_candidates(temu_tabs, collection_tabs)
        fallback_selectors = [
            ".jx-radio-button:has-text('å…¨éƒ¨')",
            ".pro-radio-button:has-text('å…¨éƒ¨')",
            ".pro-tabs__item:has-text('å…¨éƒ¨')",
            "[role='tab']:has-text('å…¨éƒ¨')",
            "button:has-text('å…¨éƒ¨')",
            "span:has-text('å…¨éƒ¨')",
            "text=å…¨éƒ¨",
        ]
        selectors = self._get_selector_candidates(configured_selectors, fallback_selectors)

        clicked_selector = await self._click_first_available(
            page,
            selectors,
            visible_timeout_ms=2_000,
            click_timeout_ms=1_500,
            attempts=2,
            context="reset_all_tab",
        )
        if clicked_selector:
            logger.info("å·²å¤ä½åˆ°ã€Œå…¨éƒ¨ã€TAB selector=%s", clicked_selector)
        else:
            logger.warning("å¤ä½åˆ°ã€Œå…¨éƒ¨ã€TAB å¤±è´¥ï¼Œæœªæ‰¾åˆ°å¯ç”¨çš?TAB æŒ‰é’®")

    async def select_shop(self, page: Page, shop_name: str | None = None) -> bool:
        """é€‰æ‹©åº—é“ºï¼ˆSOP æ­¥éª¤ 8ï¼?"""
        logger.info("=" * 60)
        logger.info("[SOP æ­¥éª¤ 8] é€‰æ‹©åº—é“º")
        await page.wait_for_load_state("domcontentloaded")

        logger.info("=" * 60)
        try:
            await self._ensure_publish_context(page)

            action_buttons = (
                self.selectors.get("temu_collect_box", {})
                .get("action_buttons", {})
            )
            configured_select_shop = action_buttons.get("select_shop")
            select_shop_candidates = self._get_selector_candidates(
                configured_select_shop,
                "button:has-text('é€‰æ‹©åº—é“º')",
                "text='é€‰æ‹©åº—é“º'",
            )

            logger.info("ç‚¹å‡»ã€Œé€‰æ‹©åº—é“ºã€æŒ‰é’?..")
            clicked = await self._click_first_available(
                page,
                select_shop_candidates,
                visible_timeout_ms=5_000,
                click_timeout_ms=3_000,
                attempts=2,
                context="select_shop.open",
            )
            if not clicked:
                raise RuntimeError("æœªèƒ½æ‰¾åˆ°ã€é€‰æ‹©åº—é“ºã€æŒ‰é’?)

            normalized_name = (shop_name or "").strip()
            skip_specific_shop = normalized_name == "" or normalized_name.lower() in {
                "æœªæŒ‡å®?,
                "all",
                "*",
            }

            if not skip_specific_shop:
                logger.info("é€‰æ‹©åº—é“º: %s", normalized_name)
                target = page.get_by_text(normalized_name, exact=False).first
                try:
                    await target.wait_for(state="visible", timeout=TIMEOUTS.SLOW)
                    await target.click(timeout=TIMEOUTS.NORMAL)
                except Exception as exc:
                    logger.warning(
                        "å®šä½åº—é“ºå¤±è´¥ï¼Œå°†å°è¯•å…¨é€‰åº—é“?name=%s err=%s",
                        normalized_name,
                        exc,
                    )
                    await self._select_all_shops(page)
            else:
                logger.info("æœªæŒ‡å®šåº—é“ºï¼Œç›´æ¥å…¨é€‰æ‰€æœ‰åº—é“?)
                await self._select_all_shops(page)

            await self._confirm_shop_selection(page)

            logger.success("åº—é“ºé€‰æ‹©å®Œæˆ")
            return True
        except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
            logger.error("é€‰æ‹©åº—é“ºå¤±è´¥: %s", exc)
            self._invalidate_publish_context()
            return False

    async def _select_all_shops(self, page: Page) -> None:
        """åœ¨åº—é“ºå¼¹çª—ä¸­å‹¾é€‰â€œå…¨é€‰â€å¤é€‰æ¡†."""
        selectors = self._get_selector_candidates(
            "label.jx-checkbox.jx-checkbox--small.pro-checkbox-group-all-select.pro-checkbox",
            "label:has-text('å…¨é€?)",
            "button:has-text('å…¨é€?)",
            "text='å…¨é€?",
            "input[type='checkbox'][aria-label*='å…¨é€?]",
        )
        await page.wait_for_load_state("domcontentloaded")

        clicked_selector = await self._click_first_available(
            page,
            selectors,
            visible_timeout_ms=2_000,
            click_timeout_ms=1_000,
            attempts=2,
            context="select_all_shops",
        )
        if clicked_selector:
            logger.success("å·²å…¨é€‰æ‰€æœ‰åº—é“?selector=%s", clicked_selector)
            return

        raise RuntimeError("æœªæ‰¾åˆ°å¯ç”¨çš„â€œå…¨é€‰â€é€‰é¡¹ï¼Œæ— æ³•ç»§ç»­é€‰æ‹©åº—é“º")

    async def _confirm_shop_selection(self, page: Page) -> None:
        """ç‚¹å‡»åº—é“ºé€‰æ‹©å¼¹çª—ä¸­çš„â€œç¡®å®?ç¡®è®¤â€æŒ‰é’?"""
        confirm_selectors = self._get_selector_candidates(
            "button.jx-button.jx-button--primary:has-text('ç¡®å®š')",
            "button.pro-button:has-text('ç¡®å®š')",
            "button:has-text('ç¡®è®¤')",
            "div[role='dialog'] button.jx-button--primary",
            "footer button.jx-button--primary",
            "button[type='button']:has-text('ç¡®å®š')",
        )
        await page.wait_for_load_state("domcontentloaded")

        clicked_selector = await self._click_first_available(
            page,
            confirm_selectors,
            visible_timeout_ms=3_000,
            click_timeout_ms=2_000,
            attempts=2,
            context="confirm_shop",
        )
        if clicked_selector:
            logger.success("å·²ç‚¹å‡»åº—é“ºç¡®è®¤æŒ‰é’?selector=%s", clicked_selector)
            return

        try:
            await page.keyboard.press("Enter")
            logger.info("å·²é€šè¿‡é”®ç›˜ Enter ç¡®è®¤åº—é“ºé€‰æ‹©")
        except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
            raise RuntimeError("æœªèƒ½æ‰¾åˆ°â€œç¡®å®?ç¡®è®¤â€æŒ‰é’®ï¼Œæ— æ³•ç¡®è®¤åº—é“ºé€‰æ‹©") from exc

    def _validate_products_data(
        self,
        products_data: Sequence[Mapping[str, Any]],
    ) -> list[float]:
        """æ ¡éªŒäº§å“æ•°æ®å¹¶æå–æˆæœ¬ä»·åˆ—è¡¨."""
        if not products_data:
            raise ValueError("äº§å“æ•°æ®ä¸ºç©ºï¼Œæ— æ³•è®¡ç®—ä¾›è´§ä»·")

        costs: list[float] = []
        for idx, product in enumerate(products_data):
            if "cost" not in product:
                raise ValueError(f"äº§å“æ•°æ®ç¼ºå°‘ cost å­—æ®µ index={idx}")
            try:
                cost_value = float(product["cost"])
            except (TypeError, ValueError) as exc:
                raise ValueError(f"æˆæœ¬å€¼éæ³?index={idx} value={product['cost']}") from exc
            if cost_value <= 0:
                raise ValueError(f"æˆæœ¬å€¼å¿…é¡»å¤§äº?0 index={idx} value={cost_value}")
            costs.append(cost_value)
        return costs

    async def _close_dialog_safely(self, page: Page) -> None:
        """å°è¯•å…³é—­å½“å‰å¼¹çª—ï¼Œé¿å…é˜»å¡åç»­æµç¨?"""
        await page.wait_for_load_state("domcontentloaded")

        close_selectors = self._get_selector_candidates(
            "button:has-text('å…³é—­')",
            "button:has-text('å–æ¶ˆ')",
            "button[aria-label='å…³é—­']",
            ".jx-dialog__close",
            ".el-dialog__close",
        )
        await self._click_first_available(
            page,
            close_selectors,
            visible_timeout_ms=8000,
            click_timeout_ms=6000,
            attempts=1,
            context="close_dialog",
        )

    async def set_supply_price(
        self,
        page: Page,
        products_data: Sequence[Mapping[str, Any]],
    ) -> bool:
        """è®¾ç½®ä¾›è´§ä»·ï¼ˆSOP æ­¥éª¤ 9ï¼?"""
        logger.info("=" * 60)
        logger.info("[SOP æ­¥éª¤ 9] è®¾ç½®ä¾›è´§ä»?)
        logger.info("=" * 60)
        # try:
        #     costs = self._validate_products_data(products_data)
        # except ValueError as exc:
        #     logger.error("ä¾›è´§ä»·æ•°æ®æ ¡éªŒå¤±è´? %s", exc)
        #     return False

        # try:
        #     await self._ensure_publish_context(page)
        #     action_buttons = (
        #         self.selectors.get("temu_collect_box", {})
        #         .get("action_buttons", {})
        #     )
        #     configured_set_price = action_buttons.get("set_price")
        #     set_price_candidates = self._get_selector_candidates(
        #         configured_set_price,
        #         "button:has-text('è®¾ç½®ä¾›è´§ä»?)",
        #         "button:has-text('ä¾›è´§ä»?)",
        #     )

        #     logger.info("ç‚¹å‡»ã€Œè®¾ç½®ä¾›è´§ä»·ã€æŒ‰é’?..")
        #     clicked_btn = await self._click_first_available(
        #         page,
        #         set_price_candidates,
        #         visible_timeout_ms=5_000,
        #         click_timeout_ms=3_000,
        #         attempts=2,
        #         context="set_price.open",
        #     )
        #     if not clicked_btn:
        #         raise RuntimeError("æœªèƒ½ç‚¹å‡»ã€è®¾ç½®ä¾›è´§ä»·ã€æŒ‰é’?)

        #     dialog_selectors = [
        #         ".el-dialog__wrapper:visible",
        #         ".jx-dialog__wrapper:visible",
        #         ".el-dialog:visible",
        #         ".jx-dialog:visible",
        #         "[role='dialog']:visible",
        #     ]
        #     dialog = await self._first_visible_locator(
        #         page,
        #         dialog_selectors,
        #         timeout_ms=TIMEOUTS.SLOW,
        #         context="set_price.dialog",
        #     )
        #     scope: Page | Locator = dialog or page

        #     pricing_dialog_cfg = (
        #         self.selectors.get("temu_collect_box", {})
        #         .get("pricing_dialog", {})
        #     )

        #     formula_selectors = self._get_selector_candidates(
        #         pricing_dialog_cfg.get("use_formula"),
        #         "label:has-text('ä½¿ç”¨å…¬å¼')",
        #         "button:has-text('ä½¿ç”¨å…¬å¼')",
        #         ".jx-radio:has-text('ä½¿ç”¨å…¬å¼')",
        #         ".el-radio:has-text('ä½¿ç”¨å…¬å¼')",
        #         "text=ä½¿ç”¨å…¬å¼",
        #     )
        #     if formula_selectors:
        #         await self._click_first_available(
        #             scope,  # type: ignore[arg-type]
        #             formula_selectors,
        #             visible_timeout_ms=1_200,
        #             click_timeout_ms=1_000,
        #             attempts=2,
        #             context="set_price.use_formula",
        #         )

        #     multiplier_selectors = self._get_selector_candidates(
        #         pricing_dialog_cfg.get("multiplier"),
        #         "input[placeholder*='å€æ•°']",
        #         "input[type='number']",
        #     )
        #     multiplier = await self._first_visible_locator(
        #         scope,  # type: ignore[arg-type]
        #         multiplier_selectors,
        #         timeout_ms=TIMEOUTS.NORMAL,
        #         context="set_price.multiplier",
        #     )
        #     if multiplier:
        #         await multiplier.fill("3")
        #         logger.info("å€æ•°è¾“å…¥æ¡†å·²å¡«å…… 3ï¼ˆä¾›è´§ä»· = æˆæœ¬ Ã— 7.5ï¼?)
        #     else:
        #         logger.warning("æœªæ‰¾åˆ°å€æ•°è¾“å…¥æ¡†ï¼Œå°†è·³è¿‡å€æ•°å¡«å……")

        #     apply_selectors = self._get_selector_candidates(
        #         pricing_dialog_cfg.get("apply"),
        #         "button:has-text('åº”ç”¨')",
        #         "button:has-text('ç¡®å®š')",
        #     )
        #     apply_clicked = await self._click_first_available(
        #         scope,  # type: ignore[arg-type]
        #         apply_selectors,
        #         visible_timeout_ms=2_000,
        #         click_timeout_ms=1_500,
        #         attempts=2,
        #         context="set_price.apply",
        #     )
        #     if not apply_clicked:
        #         raise RuntimeError("æœªèƒ½ç‚¹å‡»ã€åº”ç”¨ã€æˆ–ã€ç¡®å®šã€æŒ‰é’?)

        #     supply_prices = [
        #         self.price_calculator.calculate_supply_price(cost) for cost in costs
        #     ]
        #     logger.info(
        #         "ä¾›è´§ä»·åŒºé—? %.2f - %.2f (åŸºäº %s ä¸ªäº§å“?",
        #         min(supply_prices),
        #         max(supply_prices),
        #         len(supply_prices),
        #     )

        #     close_selectors = self._get_selector_candidates(
        #         pricing_dialog_cfg.get("close"),
        #         "button:has-text('å…³é—­')",
        #         "button:has-text('ç¡®å®š')",
        #     )
        #     await self._click_first_available(
        #         scope,  # type: ignore[arg-type]
        #         close_selectors,
        #         visible_timeout_ms=1_000,
        #         click_timeout_ms=800,
        #         attempts=1,
        #         context="set_price.close",
        #     )

        #     logger.success("ä¾›è´§ä»·è®¾ç½®å®Œæˆï¼ˆå…¬å¼å€æ•° 3ï¼?)
        #     self._publish_context_ready = True
        #     return True
        # except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
        #     logger.error("è®¾ç½®ä¾›è´§ä»·å¤±è´? %s", exc)
        #     self._invalidate_publish_context()
        #     await self._close_dialog_safely(page)
        #     return False
        #ç¦ç”¨ä¾›è´§ä»·è®¾ç½?

    async def _handle_pre_publish_modal(self, page: Page) -> None:
        """å¤„ç†æ‰¹é‡å‘å¸ƒå‰ç½®æç¤ºå¼¹çª—ï¼ˆå¯é€‰å‡ºç°ï¼‰ã€?""
        confirm_first_selectors = self._get_selector_candidates(
            "button:has-text('æˆ‘çŸ¥é“äº†')",
            "button:has-text('ç¡®è®¤')",
            "button:has-text('ç¡®å®š')",
            "text='æˆ‘çŸ¥é“äº†'",
        )
        await page.wait_for_load_state("domcontentloaded")

        confirm_first_clicked = await self._click_first_available(
            page,
            confirm_first_selectors,
            visible_timeout_ms=TIMEOUTS.SLOW,
            click_timeout_ms=TIMEOUTS.SLOW,
            attempts=3,
            context="batch_publish.pre_modal",
        )
        if confirm_first_clicked:
            logger.info("å·²å…³é—­å‰ç½®æç¤ºå¼¹çª?selector=%s", confirm_first_clicked)
            await asyncio.sleep(0.2)

    async def batch_publish(self, page: Page) -> bool:
        """æ‰¹é‡å‘å¸ƒï¼ˆSOP æ­¥éª¤ 10ï¼?"""
        logger.info("=" * 60)
        logger.info("[SOP æ­¥éª¤ 10] æ‰¹é‡å‘å¸ƒ")
        logger.info("=" * 60)
        try:
            await page.wait_for_load_state("domcontentloaded")

            publish_cfg = self.selectors.get("publish", {})
            repeat_cfg = publish_cfg.get("repeat_per_batch", 5)
            try:
                repeat_per_batch = int(repeat_cfg)
                repeat_per_batch = max(1, min(repeat_per_batch, 10))
            except Exception:
                repeat_per_batch = 5

            action_buttons = (
                self.selectors.get("temu_collect_box", {})
                .get("action_buttons", {})
            )
            configured_batch_publish = action_buttons.get("batch_publish")
            publish_btn_candidates = self._get_selector_candidates(
                configured_batch_publish,
                "button:has-text('æ‰¹é‡å‘å¸ƒ')",
                "button:has-text('å‘å¸ƒ')",
            )
            flag=False
            for round_idx in range(repeat_per_batch):
                logger.info(
                    ">>> æ‰¹é‡å‘å¸ƒ %s/%s æ¬¡ï¼Œå…?20 æ¡äº§å“?,
                    round_idx + 1,
                    repeat_per_batch,
                )
                await self._reset_to_all_tab(page)
                await self._ensure_publish_context(page, force=True)

                logger.info("[1/2] ç‚¹å‡»ã€Œæ‰¹é‡å‘å¸ƒã€æŒ‰é’?..")
                publish_clicked = await self._click_first_available(
                    page,
                    publish_btn_candidates,
                    visible_timeout_ms=10_000,
                    click_timeout_ms=8_000,
                    attempts=3,
                    context="batch_publish.open",
                )
                if not publish_clicked:
                    raise RuntimeError("æœªèƒ½ç‚¹å‡»ã€Œæ‰¹é‡å‘å¸ƒã€æŒ‰é’?)
                logger.info("æ‰¹é‡å‘å¸ƒæŒ‰é’®å‘½ä¸­ selector=%s", publish_clicked)
                # ç¡¬ç¼–ç ç­‰å¾?5.5sï¼Œç­‰å¾…å¼¹çª—æ¸²æŸ?
                if not flag:
                    await asyncio.sleep(5.5)
                    await self._handle_pre_publish_modal(page)
                    flag=True

                confirm_publish_selectors = self._get_selector_candidates(
                    "button:has-text('ç¡®è®¤å‘å¸ƒ')",
                )
                logger.info("[2/2] ç¡®è®¤å‘å¸ƒ...")
                confirm_publish_clicked = await self._click_first_available(
                    page,
                    confirm_publish_selectors,
                    visible_timeout_ms=8_000,
                    click_timeout_ms=8_000,
                    attempts=3,
                    context="batch_publish.confirm",
                )
                if not confirm_publish_clicked:
                    raise RuntimeError("æœªèƒ½ç‚¹å‡»ã€Œç¡®è®¤å‘å¸ƒã€æŒ‰é’?)

                close_retry_cfg = (
                    self.selectors.get("publish_confirm", {}).get("close_retry", 5)
                )
                try:
                    close_retry = int(close_retry_cfg)
                    close_retry = max(1, min(close_retry, 10))
                except Exception:
                    close_retry = 5

                close_button_selectors = self._get_selector_candidates(
                    "button:has-text('å…³é—­')",
                    "button:has-text('å–æ¶ˆ')",
                    "button:has-text('ç¡®å®š')",
                )

                close_button = None
                for attempt in range(close_retry):
                    close_button = await self._click_first_available(
                        page,
                        close_button_selectors,
                        visible_timeout_ms=8_000,
                        click_timeout_ms=6_000,
                        attempts=3,
                        context=f"batch_publish.close[{attempt+1}/{close_retry}]",
                    )
                    if close_button:
                        logger.info(
                            "å…³é—­æŒ‰é’®å‘½ä¸­ selector=%s (å°è¯• %s/%s)",
                            close_button,
                            attempt + 1,
                            close_retry,
                        )
                        break
                    await asyncio.sleep(0.3)

                if not close_button:
                    raise RuntimeError("æœªèƒ½ç‚¹å‡»ã€Œå…³é—­ã€æŒ‰é’?)

                self._invalidate_publish_context()

            logger.success(
                "æ‰¹é‡å‘å¸ƒå®Œæˆ 20 æ¡äº§å“?%s æ¬¡ï¼Œå…?%s æ¡äº§å“?,
                repeat_per_batch,
                20 * repeat_per_batch,
            )
            return True
        except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
            logger.error("æ‰¹é‡å‘å¸ƒå¤±è´¥: %s", exc)
            return False
        finally:
            self._invalidate_publish_context()

    async def execute_publish_workflow(
        self,
        page: Page,
        products_data: Sequence[Mapping[str, Any]],
        shop_name: str | None = None,
    ) -> dict[str, Any]:
        """æ‰§è¡Œå‘å¸ƒå·¥ä½œæµï¼ˆSOP æ­¥éª¤ 8-10ï¼?"""
        logger.info("=" * 80)
        logger.info("å¼€å§‹æ‰§è¡Œå‘å¸ƒå·¥ä½œæµï¼ˆSOP æ­¥éª¤ 8-10ï¼?)
        logger.info("=" * 80)

        result = PublishWorkflowResult()

        try:
            logger.info("\n[å‡†å¤‡] å…¨é€?20 æ¡äº§å“?..")
            await self.select_all_20_products(page)

            logger.info("\n[æ­¥éª¤ 8] é€‰æ‹©åº—é“º...")
            result.shop_selected = await self.select_shop(page, shop_name)

            # logger.info("\n[æ­¥éª¤ 9] è®¾ç½®ä¾›è´§ä»?..")
            # result.price_set = await self.set_supply_price(page, products_data)

            logger.info("\n[æ­¥éª¤ 10] æ‰¹é‡å‘å¸ƒ...")
            result.published = await self.batch_publish(page)

            logger.info("\n" + "=" * 80)
            logger.info("å‘å¸ƒå·¥ä½œæµæ‰§è¡Œå®Œæ¯?)
            logger.info("æ‰§è¡Œç»“æœ: %s", "âœ?æˆåŠŸ" if result.success else "â?å¤±è´¥")
            logger.info("=" * 80)
            return result.to_dict()
        except Exception as exc:  # pragma: no cover - è¿è¡Œæ—¶ä¿æŠ?
            logger.error("å‘å¸ƒå·¥ä½œæµæ‰§è¡Œå¤±è´? %s", exc)
            return result.to_dict()


# æµ‹è¯•ä»£ç 
if __name__ == "__main__":
    # è¯¥æ§åˆ¶å™¨éœ€è¦?Playwright Page å¯¹è±¡ï¼Œå•ç‹¬è¿è¡Œä»…ç”¨äºå ä½
    pass
